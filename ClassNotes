Making Node- just make node 
Add front- make a node for the head, if empty make it the head, if not make a new node-point at the old node-change new node to the head.
Traverse and Print everything- create a current node(to avoid losing reference), in loop check that it is not null and print currnode value and point it to the next
Size- Do above and just count
min/max- same thing iterate through and determine value bigger or smaller
find- traverse and set a conditional for the value you want and count the values until you get the value
remove front- create a node to delete pointer and set it to head, set head to next value, delete og pointer

Class- creates new data type or add functionality to existing types
Object- variable/instance of defined class
class.object
UML- attributes(variables) and behaviors(functions)
Class- Declaration and Definition- declares data methods(functions) and members(variables)
Scope required for funciton implementation

Constructor function to avoid it not existing- Enforce rules for constructing here as well
Add parameters to constructor if needed
Use private section to enforce rules
Getters and Setters- ways to call private variables without allowing access and to change private variables

overload base operators with our class as well
Destructor, Copy Assignment(Deep), Copy Constructor(Deep) (Rule of 3- make all of them if you make one)
const fuctions- getters and constructors
Templates- Define type as T within the class we create so we can create objects of any types template<typename T>
Place templates lower then class definition- .h, .cpp, .hpp (use .hpp for header implementation because you cna't compile on own)(cpp is reserver for standalone compiling)

Singly-Linked List- what we've been doing- just one link to next node
Doubly-Linked List- Have a link going forwards and backwards- pNext and pPrev - can go backwards easier - '
adding to front
  NN->N=h
  h->p = nn
  h=nn
adding node in middle
  NN->p = curr
  NN->N = curr->N
  curr->N->P = NN
  Curr->N = NN
Adding node at end
  t->N == NN
  NN->p = t
  t = NN
Circularly-Linked List- Tail points to head in single and in double tail points to head and head previous points to tail- Same idea as single and double just one thing changes

Sorting (purpose of reducing searching complexity) 
Selection- Iterate over entire list, find smallest value and put at front then next and so on. Start from the position+1 you just swapped. Requires a temp variable to implement.
Shallow copy with linked list
Insertion- Iterate over list once, checking where your current value belongs in what you have already sorted.  Check if it is smaller or larger then stuff before. Sort as you go
Bubble- Bubble defined as a pair of values in the list.  First swap the values as you go and with one pass you would get the largest value sorted.  Repeat for however many elements.  If you make a pass and don't swap anything then everything is in order. Probably easiest.
